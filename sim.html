<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SHIELD 1.0 â€“ IMU X-Frame</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0b0f14;
    }
  </style>
</head>

<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152/build/three.min.js"></script>

<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(4, 3, 6);
camera.lookAt(0, 0, 0);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(6, 10, 8);
scene.add(dir);

/* ================= GRID ================= */
scene.add(new THREE.GridHelper(10, 10, 0x223344, 0x112233));

/* ================= DRONE (X-PRISM) ================= */
const drone = new THREE.Group();

/* Arm material */
const armMat = new THREE.MeshStandardMaterial({ color: 0x00d4ff });

/* X arms */
const arm1 = new THREE.Mesh(
  new THREE.BoxGeometry(3.2, 0.18, 0.18),
  armMat
);
arm1.rotation.y = Math.PI / 4;

const arm2 = new THREE.Mesh(
  new THREE.BoxGeometry(3.2, 0.18, 0.18),
  armMat
);
arm2.rotation.y = -Math.PI / 4;

drone.add(arm1);
drone.add(arm2);

/* Center body */
const body = new THREE.Mesh(
  new THREE.BoxGeometry(0.6, 0.3, 0.6),
  new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
);
drone.add(body);

/* Nose indicator (FORWARD) */
const nose = new THREE.Mesh(
  new THREE.BoxGeometry(0.4, 0.25, 0.8),
  new THREE.MeshStandardMaterial({ color: 0xff4444 })
);
nose.position.z = 0.7;
drone.add(nose);

/* Lift above grid */
drone.position.y = 1.0;
scene.add(drone);

/* ================= TARGET QUATERNION ================= */
const targetQuat = new THREE.Quaternion();

/* ================= WEBSOCKET ================= */
const ws = new WebSocket("ws://localhost:8765");

ws.onmessage = e => {
  const q = JSON.parse(e.data);

  if (
    q.qw === undefined ||
    q.qx === undefined ||
    q.qy === undefined ||
    q.qz === undefined
  ) return;

  // DIRECT quaternion mapping (no Euler)
  targetQuat.set(
    q.qx,
    q.qy,
    q.qz,
    q.qw
  ).normalize();
};

/* ================= ANIMATE ================= */
function animate() {
  requestAnimationFrame(animate);

  // Smooth, physically correct rotation
  drone.quaternion.slerp(targetQuat, 0.25);

  renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
